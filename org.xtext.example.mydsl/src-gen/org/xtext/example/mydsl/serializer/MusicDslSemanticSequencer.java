/*
 * generated by Xtext 2.21.0
 */
package org.xtext.example.mydsl.serializer;

import com.google.inject.Inject;
import java.util.Set;
import musicMetamodel.Clef;
import musicMetamodel.Composition;
import musicMetamodel.Key;
import musicMetamodel.Measure;
import musicMetamodel.MusicMetamodelPackage;
import musicMetamodel.Notation;
import musicMetamodel.Note;
import musicMetamodel.Repetition;
import musicMetamodel.Rest;
import musicMetamodel.Staff;
import musicMetamodel.TimeSignature;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.xtext.example.mydsl.services.MusicDslGrammarAccess;

@SuppressWarnings("all")
public class MusicDslSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private MusicDslGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == MusicMetamodelPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case MusicMetamodelPackage.CLEF:
				sequence_Clef(context, (Clef) semanticObject); 
				return; 
			case MusicMetamodelPackage.COMPOSITION:
				sequence_Composition(context, (Composition) semanticObject); 
				return; 
			case MusicMetamodelPackage.KEY:
				sequence_Key(context, (Key) semanticObject); 
				return; 
			case MusicMetamodelPackage.MEASURE:
				sequence_Measure(context, (Measure) semanticObject); 
				return; 
			case MusicMetamodelPackage.NOTATION:
				sequence_Notation(context, (Notation) semanticObject); 
				return; 
			case MusicMetamodelPackage.NOTE:
				sequence_Note(context, (Note) semanticObject); 
				return; 
			case MusicMetamodelPackage.REPETITION:
				sequence_Repetition(context, (Repetition) semanticObject); 
				return; 
			case MusicMetamodelPackage.REST:
				sequence_Rest(context, (Rest) semanticObject); 
				return; 
			case MusicMetamodelPackage.STAFF:
				sequence_Staff(context, (Staff) semanticObject); 
				return; 
			case MusicMetamodelPackage.TIME_SIGNATURE:
				sequence_TimeSignature(context, (TimeSignature) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Clef returns Clef
	 *
	 * Constraint:
	 *     type=ClefType?
	 */
	protected void sequence_Clef(ISerializationContext context, Clef semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Composition returns Composition
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         author=EString? 
	 *         instrument=EString? 
	 *         tonality=EString? 
	 *         soundTempo=EInt? 
	 *         staff+=Staff 
	 *         staff+=Staff*
	 *     )
	 */
	protected void sequence_Composition(ISerializationContext context, Composition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Key returns Key
	 *
	 * Constraint:
	 *     fifths=EInt
	 */
	protected void sequence_Key(ISerializationContext context, Key semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MusicMetamodelPackage.Literals.KEY__FIFTHS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MusicMetamodelPackage.Literals.KEY__FIFTHS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getKeyAccess().getFifthsEIntParserRuleCall_0(), semanticObject.getFifths());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     StaffElement returns Measure
	 *     Measure returns Measure
	 *
	 * Constraint:
	 *     (measureNumber=EInt (repetition+=Repetition repetition+=Repetition*)? (rest+=Rest rest+=Rest*)? (note+=Note note+=Note*)?)
	 */
	protected void sequence_Measure(ISerializationContext context, Measure semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Notation returns Notation
	 *
	 * Constraint:
	 *     (articulation=ArticulationType? ornament=OrnamentType? slur=SlurType?)
	 */
	protected void sequence_Notation(ISerializationContext context, Notation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     StaffElement returns Note
	 *     Note returns Note
	 *
	 * Constraint:
	 *     (
	 *         name=NoteName 
	 *         type=NoteType? 
	 *         duration=EInt? 
	 *         octave=EInt? 
	 *         voice=EInt? 
	 *         dynamic=EString? 
	 *         accidental=AccidentalType? 
	 *         lyrics=EString? 
	 *         fermata?='fermata'? 
	 *         dot?='dot'? 
	 *         chord?='chord'? 
	 *         (notation+=Notation notation+=Notation*)?
	 *     )
	 */
	protected void sequence_Note(ISerializationContext context, Note semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     StaffElement returns Repetition
	 *     Repetition returns Repetition
	 *
	 * Constraint:
	 *     type=RepetitionType?
	 */
	protected void sequence_Repetition(ISerializationContext context, Repetition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     StaffElement returns Rest
	 *     Rest returns Rest
	 *
	 * Constraint:
	 *     type=RestType?
	 */
	protected void sequence_Rest(ISerializationContext context, Rest semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Staff returns Staff
	 *
	 * Constraint:
	 *     (staffNumber=EInt clef=Clef key=Key? time=TimeSignature (elements+=StaffElement elements+=StaffElement*)?)
	 */
	protected void sequence_Staff(ISerializationContext context, Staff semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TimeSignature returns TimeSignature
	 *
	 * Constraint:
	 *     (beat=EInt beatType=EInt)
	 */
	protected void sequence_TimeSignature(ISerializationContext context, TimeSignature semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MusicMetamodelPackage.Literals.TIME_SIGNATURE__BEAT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MusicMetamodelPackage.Literals.TIME_SIGNATURE__BEAT));
			if (transientValues.isValueTransient(semanticObject, MusicMetamodelPackage.Literals.TIME_SIGNATURE__BEAT_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MusicMetamodelPackage.Literals.TIME_SIGNATURE__BEAT_TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTimeSignatureAccess().getBeatEIntParserRuleCall_1_0(), semanticObject.getBeat());
		feeder.accept(grammarAccess.getTimeSignatureAccess().getBeatTypeEIntParserRuleCall_4_0(), semanticObject.getBeatType());
		feeder.finish();
	}
	
	
}
